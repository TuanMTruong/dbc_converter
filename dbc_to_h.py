#! /usr/bin/python

import cantools as ct
import argparse



def writeLine(fd,string=''):
	fd.write(string + '\n')


parser = argparse.ArgumentParser(description='Convert CAN DBC file to C++ code.')
parser.add_argument('dbc', type=str, help='DBC file.')
parser.add_argument('-o', type=str, help='Output file', dest='out_file')
args = parser.parse_args()

dbc_filename = args.dbc
output_filename = args.out_file

messages = ct.db.load_file(dbc_filename).messages
print 'DBC file:', dbc_filename
print 'Number of messages:', len(messages)

fd = open(output_filename, 'wt')

writeLine(fd, '/******************************** DO NOT EDIT THIS FILE, IT WAS AUTOMATICALLY GENERATED ********************************/')
writeLine(fd, '#pragma once')
writeLine(fd, '#include <stdint.h>')
writeLine(fd)

# print messages[0]
# print messages[0].signals[0]


writeLine(fd, 'typedef enum CAN_IDS {')

for m in messages:
	fd.write('\t'+ m.name + '_id = ' + str(m.frame_id))
	if m == messages[-1]:
		writeLine(fd)
	else:
		writeLine(fd, ',')

writeLine(fd, '} Message_IDs;')

writeLine(fd)

for m in messages:

	dataStructName = m.name# + '_data'

	writeLine(fd, '// ' + m.name)

	# created enum for signals that specifies choices.
	# There is a problem if multple signals in dbc specify same choices.
	# Can't have enums with same members.
	# for s in m.signals:
	# 	if s.choices:
	# 		writeLine(fd, 'typedef enum ' + m.name + '_' + s.name + '_t' + '{')
	# 		choiceLength = len(s.choices)
	# 		num = 0
	# 		for c in s.choices:
	# 			num = num + 1;
	# 			line = '\t' + s.choices[c].replace(' ','_') + ' = ' + str(c)
	# 			if num < choiceLength:
	# 				line = line + ','

	# 			writeLine(fd, line)
	# 		writeLine(fd, '};')
	# 		writeLine(fd)

	writeLine(fd, 'struct __attribute__((_packed__)) ' + dataStructName + '{')
	for s in m.signals:
		typeName = ''
		# if s.choices:
		# 	typeName = m.name + '_' + s.name + '_t'
		# else:
		if not s.is_signed:
			typeName = typeName + 'u'
		typeName = typeName +'int' + str(s.length) + '_t'
		writeLine(fd, '\t// min = ' + str(s.minimum) + ' max = ' + str(s.maximum) + ' units: ' + str(s.unit))
		writeLine(fd, '\t// ' + s.byte_order)
		writeLine(fd, '\t' + typeName + ' ' + s.name + ';')
	writeLine(fd, '};')
	writeLine(fd)


writeLine(fd, '/**********************************************************************************************************************/')